#!/bin/bash

set -e

FUNC_NAME="$1"
SOURCE_PKG_NAME="$2"
FILE_PATH="$3"

if [ -z "$FUNC_NAME" ] || [ -z "$FILE_PATH" ]; then
	echo "Usage: $0 <function_name> <file_path>"
	exit 1
fi

TMP_FILE=$(mktemp)
LINE_NO=$(ggrep -nE "^[[:space:]]*func[[:space:]]+.*${FUNC_NAME}[[:space:]]*\(" "$FILE_PATH" | cut -d: -f1)

gawk -v start="$LINE_NO" -v FUNC_NAME="$FUNC_NAME" -v DUPLICATE="$DUPLICATE" '
  BEGIN {
    need_context = 1
    need_logger = 1
    in_import = 0
    in_func = 0
    func_buffer = ""
  }

  function v3loggify(s) {
    gsub(/\<log\./, "logger.WithContextV3(ctx, nil).", s)
    gsub(/\<logger.Log\./, "logger.WithContextV3(ctx, nil).", s)
    gsub(/logger\.WithUser\([^)]*\)\./, "logger.WithContextV3(ctx, nil).", s)
    gsub(/logger\.WithWorkflow\([^)]*\)\./, "logger.WithContextV3(ctx, nil).", s)
    gsub(/logger\.WithSourceEntity\([^)]*\)\./, "logger.WithContextV3(ctx, nil).", s)
    gsub(/logger\.WithLoanApplication\([^)]*\)\./, "logger.WithContextV3(ctx, nil).", s)
    return s
  }

  function v3sentrify(s) {
    gsub(/errorHandler\.ReportToSentryWithoutRequest\([^)]*\)/,
          "errorHandler.ReportToSentryV3(ctx, err, nil)", s)
    gsub(/errorHandler\.ReportToSentryWithFields\([^)]*\)/,
          "errorHandler.ReportToSentryV3(ctx, err, nil)", s)
    return s
  }

  function db_contexify(s) {
    methods[0] = "Get"
    methods[1] = "Exec"
    methods[2] = "Select"
    methods[3] = "NamedExec"

    for (i in methods) {
      gsub("database\\." methods[i] "\\(", "database." methods[i] "Context(ctx, ", s)
      gsub("tx\\." methods[i] "\\(", "tx." methods[i] "Context(ctx, ", s)
    }

    return s
  }

  function redis_contexify(s) {
    gsub(/rdb\.Set\(context\.Background\(\),/, "rdb.Set(ctx,", s)
    gsub(/redis\.Get\(context\.TODO\(\),/, "redis.Get(ctx,", s)
    gsub(/redis\.Get\(context\.Background\(\),/, "redis.Get(ctx,", s)
    gsub(/redis\.Set\(/, "redis.Set(ctx, ", s)
    return s
  }

  function correct_contexify(s) {
    gsub(/\<context\.TODO\(\)/, "ctx", s)
    gsub(/\<context\.Background\(\)/, "ctx", s)
    return s
  }

  function replace_interface_with_any(s) {
    gsub(/\<interface\s*\{\s*\}/, "any", s)
    return s
  }

  function function_contexify(s) {
    gsub(/IsSourceAgg\(/, "IsSourceAgg(ctx, ", s)
    gsub(/GetEMIDateThreshold\(/, "GetEMIDateThreshold(ctx, ", s)
    gsub(/IsTopUpJourney\(/, "IsTopUpJourney(ctx, ", s)
    return s
  }

  function apply_all_transformations(s) {
    s = db_contexify(s)
    s = redis_contexify(s)
    # s = v3loggify(s)
    # s = v3sentrify(s)
    # s = function_contexify(s)
    s = correct_contexify(s)
    s = replace_interface_with_any(s)
    return s
  }

  function inject_ctx_param(sig_line) {
    if (sig_line ~ /ctx[[:space:]]+context\.Context/) return sig_line
    if (sig_line ~ /\([[:space:]]*\)/) return gensub(/\([[:space:]]*\)/, "(ctx context.Context)", 1, sig_line)
    return gensub(/\(([^)]*)\)/, "(ctx context.Context, \\1)", 1, sig_line)
  }

  {
    # Handle imports
    if ($0 ~ /^import[[:space:]]*\(/) in_import = 1

    if (in_import && $0 ~ /"context"/) need_context = 0
    if (in_import && $0 ~ /"finbox\/go-api\/functions\/logger"/) need_logger = 0

    if (in_import && $0 ~ /^\)/) {
      if (need_context) print "\t\"context\""
      if (need_logger) print "\t\"finbox/go-api/functions/logger\""
      in_import = 0
    }

    # Before function: print as is
    if (NR < start) {
      print
      next
    }

    # Detect function start
    if (NR == start) {
      in_func = 1
      brace_count = gsub(/{/, "{") - gsub(/}/, "}")
      func_buffer = $0 "\n"
      next
    }

    # Accumulate full function
    if (in_func) {
      func_buffer = func_buffer $0 "\n"
      brace_count += gsub(/{/, "{")
      brace_count -= gsub(/}/, "}")
      if (brace_count == 0) {
        in_func = 0

        # Modify original function
        split(func_buffer, lines, "\n")
        lines[1] = inject_ctx_param(lines[1])

        mod_buf = lines[1]
        for (i = 2; i <= length(lines)-1; i++) mod_buf = mod_buf "\n" lines[i]

        print apply_all_transformations(mod_buf)

        next
      }
      next
    }

    # After function
    print
  }
' "$FILE_PATH" >"$TMP_FILE"

mv "$TMP_FILE" "$FILE_PATH"
echo "✅ Contexified $FUNC_NAME definition"

rg --pcre2 -l "(?:${SOURCE_PKG_NAME}\.)?${FUNC_NAME}\(" --glob '*.go' |
	while read -r file; do
		FILE_PKG=$(awk '/^package / {print $2; exit}' "$file")

		if [[ "$FILE_PKG" == "$SOURCE_PKG_NAME" ]]; then
			# Unqualified calls
			perl -pi -e "s/(?<!\.)\b${FUNC_NAME}\((?!\s*(ctx|context))/${FUNC_NAME}(context.TODO(), /g" "$file"
			echo "✅ Contexified $FUNC_NAME references in $file"
		else
			# Qualified calls
			perl -pi -e "s/\b${SOURCE_PKG_NAME}\.${FUNC_NAME}\((?!\s*(ctx|context))/${SOURCE_PKG_NAME}.${FUNC_NAME}(context.TODO(), /g" "$file"
			echo "✅ Contexified ${SOURCE_PKG_NAME}.${FUNC_NAME} references in $file"
		fi

	done

goimports -w .
echo "✅ Fixed imports across the project"
