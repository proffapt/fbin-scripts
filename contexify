#!/bin/bash

set -e

FUNC_NAME="$1"
LINE_NO="$2"
SOURCE_PKG_NAME="$3"
FILE_PATH="$4"

if [ -z "$FUNC_NAME" ] || [ -z "$LINE_NO" ] || [ -z "$SOURCE_PKG_NAME" ] || [ -z "$FILE_PATH" ]; then
	echo "Usage: $0 <function_name> <line_no> <source_pkg_name> <file_path>"
	exit 1
fi

TMP_FILE=$(mktemp)
gawk -v start="$LINE_NO" -v FUNC_NAME="$FUNC_NAME" '
  BEGIN {
    need_context = 1
    need_logger = 1
    in_import = 0
    in_func = 0
    func_buffer = ""
  }

  function v3loggify(s) {
    gsub(/\<log\./, "logger.WithContextV3(ctx, nil).", s)
    gsub(/\<logger.Log\./, "logger.WithContextV3(ctx, nil).", s)
    gsub(/logger\.WithUser\([^)]*\)\./, "logger.WithContextV3(ctx, nil).", s)
    gsub(/logger\.WithWorkflow\([^)]*\)\./, "logger.WithContextV3(ctx, nil).", s)
    gsub(/logger\.WithSourceEntity\([^)]*\)\./, "logger.WithContextV3(ctx, nil).", s)
    gsub(/logger\.WithLoanApplication\([^)]*\)\./, "logger.WithContextV3(ctx, nil).", s)
    return s
  }

  function v3sentrify(s) {
    gsub(/errorHandler\.ReportToSentryWithoutRequest\([^)]*\)/,
          "errorHandler.ReportToSentryV3(ctx, err, nil)", s)
    gsub(/errorHandler\.ReportToSentryWithFields\([^)]*\)/,
          "errorHandler.ReportToSentryV3(ctx, err, nil)", s)
    return s
  }

  function db_contexify(s) {
    methods[0] = "Get"
    methods[1] = "Exec"
    methods[2] = "Select"
    methods[3] = "NamedExec"

    for (i in methods) {
      gsub("database\\." methods[i] "\\(", "database." methods[i] "Context(ctx, ", s)
      gsub("tx\\." methods[i] "\\(", "tx." methods[i] "Context(ctx, ", s)
    }

    return s
  }

  function redis_contexify(s) {
    s = add_ctx_if_missing(s, "redis.Set")
    s = add_ctx_if_missing(s, "redis.Get")
    return s
  }

  function replace_todo_background_with_ctx(s) {
    gsub(/\<context\.TODO\(\)/, "ctx", s)
    gsub(/\<context\.Background\(\)/, "ctx", s)
    return s
  }

  function replace_interface_with_any(s) {
    gsub(/\<interface\s*\{\s*\}/, "any", s)
    return s
  }

  function apply_all_transformations(s) {
    s = replace_interface_with_any(s)
    s = replace_todo_background_with_ctx(s)

    s = redis_contexify(s)
    s = db_contexify(s)
    # s = v3sentrify(s)
    # s = v3loggify(s)
    return s
  }

  # Utility: add ctx only if missing
  function add_ctx_if_missing(s, func_name) {
    pattern = func_name "\\("
    ctx_pattern = func_name "\\(ctx,"
    if (s ~ pattern && s !~ ctx_pattern) {
      gsub(pattern, func_name "(ctx, ", s)
    }
    return s
  }

  function inject_ctx_param(sig_line) {
    if (sig_line ~ /Cont\(/) return sig_line
    if (sig_line ~ /ctx[[:space:]]+context\.Context/) return sig_line
    if (sig_line ~ /\([[:space:]]*\)/) return gensub(/\([[:space:]]*\)/, "(ctx context.Context)", 1, sig_line)
    return gensub(/\(([^)]*)\)/, "(ctx context.Context, \\1)", 1, sig_line)
  }

  {
    # Before function: print as is
    if (NR < start) {
      print
      next
    }

    # Detect function start
    if (NR == start) {
      in_func = 1
      brace_count = gsub(/{/, "{") - gsub(/}/, "}")
      func_buffer = $0 "\n"
      next
    }

    # Accumulate full function
    if (in_func) {
      func_buffer = func_buffer $0 "\n"
      brace_count += gsub(/{/, "{")
      brace_count -= gsub(/}/, "}")
      if (brace_count == 0) {
        in_func = 0

        # Modify original function
        split(func_buffer, lines, "\n")
        lines[1] = inject_ctx_param(lines[1])

        mod_buf = lines[1]
        for (i = 2; i <= length(lines)-1; i++) mod_buf = mod_buf "\n" lines[i]

        print apply_all_transformations(mod_buf)

        next
      }
      next
    }

    # After function
    print
  }
' "$FILE_PATH" >"$TMP_FILE"

if ! diff -q "$TMP_FILE" "$FILE_PATH" >/dev/null 2>&1; then
	mv "$TMP_FILE" "$FILE_PATH"
	goimports -w "$FILE_PATH"
	echo "✅ Contexified $FUNC_NAME definition"
fi

if [[ "$FUNC_NAME" != *Cont ]]; then
	rg --pcre2 -l "(?:${SOURCE_PKG_NAME}\.)?${FUNC_NAME}\(" --glob '*.go' --glob '!*_test.go' |
		while read -r file; do
			FILE_PKG=$(awk '/^package / {print $2; exit}' "$file")

			before=$(cksum "$file")

			if [[ "$FILE_PKG" == "$SOURCE_PKG_NAME" ]]; then
				perl -pi -e "s/^(?!\s*func\b)(.*?)(?<!\.)\b${FUNC_NAME}\((?!\s*(ctx|context))/\$1${FUNC_NAME}(context.TODO(), /g" "$file"
			else
				perl -pi -e "s/\b${SOURCE_PKG_NAME}\.${FUNC_NAME}\((?!\s*(ctx|context))/${SOURCE_PKG_NAME}.${FUNC_NAME}(context.TODO(), /g" "$file"
			fi

			after=$(cksum "$file")
			if [ "$before" != "$after" ]; then
				goimports -w "$file"
				echo "✅ Contexified $FUNC_NAME references in $file"
			fi

		done
fi
