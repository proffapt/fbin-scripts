#!/usr/bin/env bash
set -euo pipefail

GREEN=$(tput setaf 2)
RED=$(tput setaf 1)
YELLOW=$(tput setaf 3)
RESET=$(tput sgr0)

log() { echo -e "${YELLOW}[INFO]${RESET} $*"; }
success() { echo -e "${GREEN}[SUCCESS]${RESET} $*"; }
error() { echo -e "${RED}[ERROR]${RESET} $*"; }

PROJECT_DIR=$(pwd)
TMP_FILE=$(mktemp)
PROGRESS_FILE="/tmp/.context_replacements_progress"

# Cleanup function (runs on exit or Ctrl+C)
cleanup() {
	if [[ -n "${file:-}" && -f "$file.bak" ]]; then
		REL_PATH=$(grealpath --relative-to="$PROJECT_DIR" "$file")
		mv "$file.bak" "$file"
		log "Restored '$REL_PATH:$line' due to user interruption."
	fi
	rm -f "$TMP_FILE"
	# only delete stray backups that are left behind
	find "$PROJECT_DIR" -type f -name "*.bak" -delete
}
trap cleanup EXIT INT

# Flags
DO_TODO=false
DO_BACKGROUND=false

# Parse args
for arg in "$@"; do
	case "$arg" in
	--todo) DO_TODO=true ;;
	--background) DO_BACKGROUND=true ;;
	*)
		echo "Usage: $0 [--todo] [--background]"
		exit 1
		;;
	esac
done

if ! $DO_TODO && ! $DO_BACKGROUND; then
	echo "Usage: $0 [--todo] [--background]"
	exit 1
fi

log "Scanning project: $PROJECT_DIR"

# Build regex depending on args
PATTERN=""
if $DO_TODO && $DO_BACKGROUND; then
	PATTERN='context\.(TODO|Background)\(\)'
elif $DO_TODO; then
	PATTERN='context\.TODO\(\)'
elif $DO_BACKGROUND; then
	PATTERN='context\.Background\(\)'
fi

# Find occurrences (ignore *_test.go files)
grep -rn --include="*.go" --exclude="*_test.go" -E "$PATTERN" "$PROJECT_DIR" >"$TMP_FILE" || true

if [[ ! -s "$TMP_FILE" ]]; then
	log "No occurrences found for pattern: $PATTERN"
	exit 0
fi

touch "$PROGRESS_FILE"

TOTAL=$(wc -l <"$TMP_FILE" | tr -d ' ')
PROCESSED=$(wc -l <"$PROGRESS_FILE" | tr -d ' ')
log "Total remaining occurrences: $TOTAL | Already processed: $PROCESSED"

file=""
line=""
CURRENT_PROCESSED=0
while IFS=: read -r file line content; do
	match=$(echo "$content" | grep -oE "$PATTERN")
	[[ -z "$match" ]] && continue

	key="$file:$line:$match"

	# Skip if already done
	if grep -Fxq "$key" "$PROGRESS_FILE"; then
		continue
	fi

	CURRENT_PROCESSED=$((CURRENT_PROCESSED + 1))
	REL_PATH=$(grealpath --relative-to="$PROJECT_DIR" "$file")
	log "[$CURRENT_PROCESSED / $TOTAL] Processing '$REL_PATH:$line'"

	# Try ctx first
	sed -i.bak "${line}s/$match/ctx/" "$file"
	if go build ./... >/dev/null 2>&1; then
		success "{${match}} → {ctx}"
		rm -f "$file.bak"
		echo "$key" >>"$PROGRESS_FILE"
		continue
	fi

	# Restore and try r.Context()
	mv "$file.bak" "$file"
	sed -i.bak "${line}s/$match/r.Context()/" "$file"
	if go build ./... >/dev/null 2>&1; then
		success "{${match}} → {r.Context()}"
		rm -f "$file.bak"
		echo "$key" >>"$PROGRESS_FILE"
		continue
	fi

	# Restore original if both failed
	mv "$file.bak" "$file"
	error "Kept {${match}}"
	echo "$key" >>"$PROGRESS_FILE"
done <"$TMP_FILE"

success "Processing complete. Progress stored in $PROGRESS_FILE"
