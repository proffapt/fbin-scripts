#!/usr/bin/env bash
set -euo pipefail

GREEN=$(tput setaf 2)
RED=$(tput setaf 1)
YELLOW=$(tput setaf 3)
RESET=$(tput sgr0)

log() { echo -e "${YELLOW}[INFO]${RESET} $*"; }
success() { echo -e "${GREEN}[SUCCESS]${RESET} $*"; }
error() { echo -e "${RED}[ERROR]${RESET} $*"; }

PROJECT_DIR=$(pwd)
TMP_FILE=$(mktemp)

# Flags
DO_TODO=false
DO_BACKGROUND=false

# Parse args
for arg in "$@"; do
	case "$arg" in
	--todo) DO_TODO=true ;;
	--background) DO_BACKGROUND=true ;;
	*)
		echo "Usage: $0 [--todo] [--background]"
		exit 1
		;;
	esac
done

if ! $DO_TODO && ! $DO_BACKGROUND; then
	echo "Usage: $0 [--todo] [--background]"
	exit 1
fi

log "Scanning project: $PROJECT_DIR"

# Build regex depending on args
PATTERN=""
if $DO_TODO && $DO_BACKGROUND; then
	PATTERN='context\.(TODO|Background)\(\)'
elif $DO_TODO; then
	PATTERN='context\.TODO\(\)'
elif $DO_BACKGROUND; then
	PATTERN='context\.Background\(\)'
fi

# Find occurrences
grep -rn --include="*.go" -E "$PATTERN" "$PROJECT_DIR" >"$TMP_FILE" || true

if [[ ! -s "$TMP_FILE" ]]; then
	log "No occurrences found for pattern: $PATTERN"
	exit 0
fi

while IFS=: read -r file line content; do
	match=$(echo "$content" | grep -oE "$PATTERN")
	[[ -z "$match" ]] && continue

	log "Processing $file:$line â†’ found '$match'"

	# Try ctx first
	sed -i.bak "${line}s/$match/ctx/" "$file"
	if go build ./... >/dev/null 2>&1; then
		success "Replaced with ctx in $file:$line"
		rm -f "$file.bak"
		continue
	fi

	# Restore and try r.Context()
	mv "$file.bak" "$file"
	sed -i.bak "${line}s/$match/r.Context()/" "$file"
	if go build ./... >/dev/null 2>&1; then
		success "Replaced with r.Context() in $file:$line"
		rm -f "$file.bak"
		continue
	fi

	# Restore original if both failed
	mv "$file.bak" "$file"
	error "Both replacements failed for $file:$line, kept original."
done <"$TMP_FILE"

rm -f "$TMP_FILE"

# Delete any dangling backup file
find . -type f -name "*.bak" -print -delete

success "Processing complete."
